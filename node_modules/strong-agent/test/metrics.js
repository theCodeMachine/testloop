var should = require('should');
var _ = require('underscore');
var http = require('http');

var nf = require('../lib/nodefly');
var proxy = require('../lib/proxy');
var info = require('../lib/info');
var metrics = require('../lib/metrics');
var loop = require('../lib/loop');


proxy.init();
info.init();
metrics.init();
loop.init();

var global_done = [];

// prep steps:
// 1. need to hook into the metric function, what a mess frankly
nf.metric = function (scope, name, value, unit, op, persist) {
	metrics.add(scope, name, value, unit, op, persist);
};
// 2. for Connections we need a functioning http server
nf.server_obj = http.createServer(function(){});

nf.on('metric', function(metric){
	// from lib/info.js
	if (metric.name === "CPU util stime") { metric.value.should.be.within(0,100); } // float
	if (metric.name === "CPU util utime") { metric.value.should.be.within(0,100); } // float
	if (metric.name === "Heap Data") { metric.value.should.be.an.instanceOf(Array) && metric.value.length.should.equal(3); } // array of 3 floats
	if (metric.name === "GC Full. V8 heap used") { metric.value.should.be.above(0); } // float and > 0
	if (metric.name === "Connections") { metric.value.should.be.an.instanceOf(Array) && metric.value.length.should.equal(2); } // array of 2 floats
	// from lib/loop.js
	if (metric.name === "queue") { metric.value.should.be.an.instanceOf(Array) && metric.value.length.should.equal(2); } // array of 2 floats
	// tiers and callCounts are not metrics, but should probably be here anyway

	// once we collect 
	//console.log('metric event', arguments);
});

// CPU, Heap metrics are initiated withing 1 second (test config)
// additional cmd parameter for GC Epilogue
// need server for Connections and tiers

// force GC
global.gc();


// giving it all 5 seconds for every metric to process
// after that exit

/*
	if (o.callCounts) {
		if (o.callCounts.strongmq_in) { metrics["strongmq_sub"] = o.callCounts.strongmq_in.count; }
		if (o.callCounts.strongmq_out) { metrics["strongmq_pub"] = o.callCounts.strongmq_out.count; }
	}
	if (o.tiers) {
		_.each(o.tiers, function(obj,key){
			metrics["tiers_"+key] = obj.avg || obj.mean || 0;

*/

describe("all metrics", function() {

	it("pass basic structure and range tests", function(done) {
		setTimeout(function(){
			done();
		}, 5000);
	});
});
